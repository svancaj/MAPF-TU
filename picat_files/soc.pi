import sat.
import aux.

main([InstanceFile]) =>
    printf("Solving %w instance file\n", InstanceFile),
    load(InstanceFile),
    Instance =  get_instance(),
    time((Plans, Final_Cost) = find_plans(Instance)),
    output(Plans, Final_Cost).

find_plans(Instance) = (Plans, Pes_LB + Delta) =>
    (N,E) = create_graph(Instance),
    Agents = get_agents(Instance),
    
    Opt_LB = get_optimistic_mks(Agents) + 1,
    Pes_LB = get_pessimistic_mks(Agents) + 1,

    printf("LB opt - %w, pes - w %w\n", Opt_LB, Pes_LB),

    between(0, 9999999, Delta),

    printf("Building formula using delta %w\n", Delta),
    Plans = create_formula(N, E, Agents, Opt_LB, Pes_LB, Delta),
    printf("SAT solver started\n"),
    solve(Plans).


create_formula(N, E, Agents, Opt_LB, Pes_LB, Delta) = At =>
    Makespan = Pes_LB + Delta,
    K = len(Agents),

    At = new_array(Makespan,K,N),
    Pass = new_array(Makespan - 1,K,E),

    % Initialize the first and last states
    foreach (A in 1..K)    
        (Start,Goal) = Agents[A],
        At[1,A,Start] = 1,

        pessimistic_path_cost((Start,Goal),Cost),
        At[Cost+Delta+1,A,Goal] = 1,
        foreach(T in Cost+Delta+1..Makespan, V in 1..N)
            if V !== Goal then
                At[T,A,V] = 0
            else
                At[T,A,V] = 1
            end
        end,

        preprocess_soc(At, Pass, Makespan, Delta, Agents, N, E)
    end,

    At :: 0..1,
    Pass :: 0..1,

    % printf("At: %w\n",At),
    % printf("Pass: %w\n",Pass),

    % CONFLICTS

    % vertex conflict
    foreach(T in 1..Makespan, V in 1..N) 
        sum([At[T,A,V] : A in 1..K]) #=< 1
    end,

    % if an edge is used in one direction, it can not be used in the other direction (no swap)
    % or in any direction for the time it is occupied
    foreach(T in 1..Makespan-1, EID in 1..E) 
        edgeid(EID,U,V,LU,UU),
        edge(OPEID,V,U,_,_),
        if V !== U then
            Tmax = min(Makespan-1, T+UU-1),
            sum([Pass[I,A,EE] : I in T..Tmax, A in 1..K, EE in [OPEID,EID]]) #=< 1
        end
    end,

    % MOVEMENT

    % if an agent is in a node, it needs to move through exactly one of the edges from that node
    foreach(T in 1..Makespan-1, A in 1..K, V in 1..N) 
        OutEdges = out_edges(V,E),
        At[T,A,V] #=> sum([Pass[T,A,W] : W in OutEdges]) #= 1
    end,

    % if an agent is in a node, it must have entered through at least one edge
    % it may have entered at different time, depending on the traversal time of the edge
    foreach(T in 2..Makespan, A in 1..K, V in 1..N) 
        InEdges = in_edges(V,E),
        At[T,A,V] #=> sum([Pass[T-I,A,W] : W in InEdges, I in get_edges_time(T,W)]) #>= 1
    end,

    % if agent is using an edge, it must arrive to the connected node in the next timesteps
    % it will be in the connected vertex in the range of the edge length
    foreach(T in 1..Makespan-1, A in 1..K, EID in 1..E) 
        edgeid(EID, _, V, LU, UU),
        foreach (W in LU..UU)
            if (T + W =< Makespan) then
                Pass[T,A,EID] #=> At[T+W,A,V] #= 1
            else
                Pass[T,A,EID] = 0
            end
        end
    end,

    % if agent is using an edge, it must have been in the starting vertex
    foreach(T in 1..Makespan-1, A in 1..K, EID in 1..E) 
        edgeid(EID, V, _, _, _),
        Pass[T,A,EID] #=> At[T,A,V]
    end,

    % SOC RESTRICTION

    % Compute end times and weighted costs
    ET = end_time(At, Agents, Makespan, N),
    sum([ET[A,T] : A in 1..K, T in 1..Makespan]) #=< Delta.
    

%  ET[A,T]=1 iff agent A is late at time T (i.e. A is not at its destination at T for T > "lower bound for agent path")
end_time(At, Agents, Makespan, N) = ET =>
    ET = new_array(len(Agents), Makespan),
    ET :: 0..1,
    foreach (A in 1..len(Agents), T in 1..Makespan)
        (Start, Goal) = Agents[A],
        pessimistic_path_cost((Start,Goal),PathLength),

        if T > PathLength then 
            %#~ At[T,A,Goal] #=> ET[A,T],  % agent is not at destination and hence it is late
            %#~ ET[A,T] #=> At[T,A,Goal],  % agent is not late and hence must be at destination

            (sum([At[T,A,V] : V in 1..N, V !== Goal]) #>= 1) #=> ET[A,T],  % agent is somewhere else than at goal and hence it is late
            #~ ET[A,T] #=> At[T,A,Goal],  % agent is not late and hence must be at destination
            %#~ ET[A,T] #=> (sum([At[T,A,V] : V in 1..N, V !== Goal]) #= 0), % agent is not late and hence must be at destination and nowhere else

            if T < Makespan then 
                #~ ET[A,T] #=> #~ ET[A,T+1]  % agent is not late at T and hence cannot be late at T+1
            end
        else
            ET[A,T] = 0  % agent is not late at T because T =< "lower bound for agent path"
        end
    end.
